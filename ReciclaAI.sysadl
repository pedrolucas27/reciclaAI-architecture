Model ReclicaAI ; package SysADL.types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } datatype UserType { attributes : name : String ; email : String ; }  dimension Weight unit KG { dimension = Weight } unit LBS { dimension = Weight } value type Weight { dimension = Weight } value type KGWeight extends Weight { unit = KG dimension = Weight } value type LBSWeight extends Weight { unit = LBS dimension = Weight } enum StatusSignal { OK , ERROR , BUSY } datatype LocationData { attributes : lat : Int ; lon : Int ; } datatype Collect { attributes : userEmail : String ; weight : Weight ; location : LocationData ; } } package ReciclaAIComponents { import ReciclaAIConnectors ; import ReciclaAIPorts ; import SysADL.types ; component def ReciclaAISystem { configuration { components : CollectController : CollectController { using ports : weight : KGWeightIPT ; presenceDetected : PresenceIPT ; ledStatus : StatusSignalOPT ; coordIn : LocationDataIPT ; user : UserTypeIPT ; collect : CollectOPT ; qrTrigger : QRTriggerOPT ;  } WeightSensor : WeightSensor { using ports : current : KGWeightOPT ; } ProximitySensor : ProximitySensor { using ports : detected : PresenceOPT ; } LEDIndicator : LEDIndicator { using ports : statusIn : StatusSignalIPT ; } GPSModule : GPSModule { using ports : coordOut : LocationDataOPT ; } QRCodeDisplay : QRCodeDisplay { using ports : qrRequest : QRTriggerIPT ; } NetworkModule : NetworkModule { using ports : CollectIPT : CollectIPT ; user : UserTypeOPT ; } connectors : weightCn : KGWeightCN bindings current = weight ; presenceCn : DetectPresenceCN bindings detected = presenceDetected ; ledsignalCN : SendStatusSignalCNN bindings ledStatus = statusIn ; locationCN : LocationCN bindings coordIn = coordOut ; qrTriggerCN : QRTriggerCN bindings qrTrigger = qrRequest ; collectCN : CollectCN bindings collect = CollectIPT ; } }
	component def WeightSensor { ports : current : KGWeightOPT ; }
	component def ProximitySensor { ports : detected : PresenceOPT ; }
	component def LEDIndicator { ports : statusIn : StatusSignalIPT ; }
	component def GPSModule { ports : coordOut : LocationDataOPT ; }
	component def QRCodeDisplay { ports : qrRequest : QRTriggerIPT ;  }
	component def NetworkModule { ports : CollectIPT : CollectIPT ; user : UserTypeOPT ; }
	component def CollectController { ports : weight : KGWeightIPT ; presenceDetected : PresenceIPT ; ledStatus : StatusSignalOPT ; coordIn : LocationDataIPT ; user : UserTypeIPT ; collect : CollectOPT ; qrTrigger : QRTriggerOPT ;  configuration { components : StartCollect : StartCollect { using ports : detected : PresenceIPT ; newPort : UserTypeIPT ; newPort : QRTriggerOPT ; newPort : UserTypeOPT ; } RegisterCollect : RegisterCollect { using ports : user : UserTypeIPT ; coordIn : LocationDataIPT ; weight : KGWeightIPT ; collect : CollectOPT ; statusOut : StatusSignalOPT ; } connectors : userCN : UserTypeCN bindings newPort = user ; delegations : detected to presenceDetected newPort to user newPort to qrTrigger coordIn to coordIn weight to weight statusOut to ledStatus collect to collect } }
	component def StartCollect { ports : detected : PresenceIPT ; user : UserTypeIPT ; qrTrigger : QRTriggerOPT ; user : UserTypeOPT ; } component def RegisterCollect { ports : user : UserTypeIPT ; coordIn : LocationDataIPT ; weight : KGWeightIPT ; collect : CollectOPT ; statusOut : StatusSignalOPT ; } activity def ValidateWeight ( weight : Weight ) : ( isValid : Boolean ) { body { actions : ValidateWeightAN : ValidateWeightAN { using pins : weight : Weight ; } delegate weight to weight delegate isValid to ValidateWeightAN } } action def ValidateWeightAN ( weight : Weight ) : Boolean { constraint : post-condition ValidateWeightEQ delegate weight to weight delegate ValidateWeightAN to isValid } constraint ValidateWeightEQ ( weight : Weight ) : ( isValid : Boolean ) { } } package ReciclaAIConnectors { import ReciclaAIPorts ; connector def LBStoKG { participants : ~ source : LBSWeightOPT ; ~ destination : KGWeightIPT ; flows : LBSWeight from source to destination } connector def KGWeightCN { participants : ~ source : KGWeightOPT ; ~ destination : KGWeightIPT ; flows : KGWeight from source to destination }  connector def SendStatusSignalCNN { participants : ~ source : StatusSignalOPT ; ~ destination : StatusSignalIPT ; flows : StatusSignal from source to destination } connector def LocationCN { participants : ~ source : LocationDataOPT ; ~ destination : LocationDataIPT ; flows : LocationData from source to destination } connector def DetectPresenceCN { participants : ~ source : PresenceOPT ; ~ destination : PresenceIPT ; flows : Boolean from source to destination } connector def QRTriggerCN { participants : ~ source : QRTriggerOPT ; ~ destination : QRTriggerIPT ; flows : Boolean from source to destination }  connector def UserTypeCN { participants : ~ source : UserTypeOPT ; ~ destination : UserTypeIPT ; flows :  UserType from source to destination } connector def CollectCN { participants : ~ source : CollectOPT ; ~ destination : CollectIPT ; flows : Collect from source to destination } } package ReciclaAIPorts { import SysADL.types ;  port def KGWeightOPT { flow out KGWeight } port def KGWeightIPT { flow in KGWeight } port def LBSWeightOPT { flow out LBSWeight } port def LBSWeightIPT { flow in LBSWeight }   port def StatusSignalOPT { flow out StatusSignal } port def StatusSignalIPT { flow in StatusSignal } port def PresenceOPT { flow out Boolean } port def PresenceIPT { flow in Boolean } port def LocationDataOPT { flow out LocationData } port def LocationDataIPT { flow in LocationData } port def UserTypeOPT { flow out UserType } port def UserTypeIPT { flow in UserType } port def QRTriggerOPT { flow out Boolean } port def QRTriggerIPT { flow in Boolean }   port def CollectOPT { flow out Collect } port def CollectIPT { flow in Collect } } Requirement ExibirQRCodeFR ( 1 ) { text = "O sistema do ponto de coleta deverá exibir, em seu display, um QR Code que possibilite ao usuário validar e registrar seu depósito, com o objetivo de acumular pontos." } Requirement ProcessarColetaFR ( 2 ) { text = "O sistema do ponto de coleta deve processar o depósito de um usuário detectando a presença e o peso do lixo, em seguinda o sistema deve registrar essas informações." Requirement DetectarLixoFR ( 2.1 ) { text = "Utilizando sensores de presença e peso previamente configurados, o sistema deve detectar quando o usuário realiza um depósito de lixo." } Requirement RegistrarPesoDaColetaFR ( 2.2 ) { text = "Após a detecção do descarte, o sistema deve registrar o peso do material descartado e, em seguida, enviar essa informação para ser persistida." } } Requirement ConfigurarPontoDeColetaFR ( 3 ) { text = " Como Administrador do sistema, desejo configurar os sensores do ponto de coleta conforme os parâmetros operacionais específicos, para garantir que o funcionamento atenda às necessidades da operação." } Requirement NotificarFalhaFR ( 4 ) { text = "O sistema do ponto de coleta deve notificar a central sempre que houver falha, a fim de garantir que os administradores sejam informados rapidamente sobre problemas no sistema." } Requirement MonitorarPontoDeColetaFR ( 5 ) { text = " Como Administrador gostaria de monitorar em tempo real o status do sistema embarcado no ponto de coleta, com foco nas informações essenciais como status de conexão, funcionamento dos sensores, entre outros dados operacionais relevantes." } Requirement AtualizarSoftwareDoPontoDeColetaFR ( 6 ) { text = " Como Administrador, desejo realizar a atualização do software do sistema embarcado no ponto de coleta, para garantir que o sistema esteja sempre operando com as versões mais recentes e seguras." } Requirement QualityNFR ( 7 ) { text = " O sistema deve atender a atributos de qualidade como conectividade, segurança, desempenho, disponibilidade, consumo de recursos e facilidade de manutenção, a fim de garantir uma solução resiliente e com alta disponibilidade para o usuário." Requirement ConectividadeNFR ( 7.1 ) { text = "O sistema embarcado deve ser capaz de se comunicar com o backend para enviar dados de coletas e notifções garantindo a integração contínua com a plataforma." } }